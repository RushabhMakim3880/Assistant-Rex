# 1.2 System Architecture Document

**Project Name:** R.E.X. (Robotic Executive Xr Assistant)  
**Version:** 1.1.0  

---

## 1. High-Level Overview
R.E.X. employs a hybrid architecture combining a high-performance React frontend for the UI and a Python backend for heavy AI processing and OS integration. Communication is bridged via a local Socket.IO server, wrapped within an Electron container for native desktop integration.

## 2. Component Breakdown

### 2.1 UI Layer (Frontend)
*   **Technology:** React 18, Vite, TailwindCSS, Framer Motion.
*   **Responsibilities:**
    *   Rendering the Holographic HUD (Heads-Up Display).
    *   Displaying real-time "Pulse Core" visualizer.
    *   Capturing user input (Text) and displaying AI responses.
    *   Visualizing system metrics (GPU/CPU widgets).

### 2.2 Application Container (Electron)
*   **Technology:** Electron (Node.js).
*   **Responsibilities:**
    *   Managing application windows (Main, Minimal, Overlay).
    *   Spawning and managing the Python backend process lifecycle.
    *   Providing OS-level hooks (Tray icon, Global shortcuts).

### 2.3 Intelligence Engine (Backend)
*   **Technology:** Python 3.12, FastAPI, Socket.IO (Async).
*   **Responsibilities:**
    *   **AudioLoop:** Handles Microphone input (PyAudio), VAD (Voice Activity Detection), and Speech-to-Text.
    *   **LLM Interface:** Manages session context with Google Gemini API.
    *   **Skill Executor:** Parses and executes function calls (e.g., `cmd`, `browser`, `media`).
    *   **Hardware Monitor:** Aggregates system stats (psutil, GPUtil).

## 3. Data Flow Architecture

1.  **Input:** User speaks -> Microphone buffer -> `AudioLoop` (Python).
2.  **Processing:**
    *   VAD detects speech end.
    *   Audio sent to STT service (or local Whisper).
    *   Transcribed text sent to Gemini LLM with system context.
3.  **Decision:** Gemini returns text response OR tool call request.
4.  **Execution:** Python backend executes requested tool (e.g., `subprocess.run`).
5.  **Output:**
    *   Text sent to TTS engine -> Audio Output.
    *   State/Response sent via Socket.IO -> React Frontend -> Visual Update.

## 4. Logical Constraints & Dependencies
*   **Internet:** Required for Gemini API connectivity.
*   **Dependencies:** Python backend relies on `ffmpeg` (bundled) and specific `PyInstaller` hooks for runtime capability.
*   **Concurrency:** The backend uses `asyncio` to handle non-blocking audio I/O while waiting for network requests.

## 6. Security Trust Boundaries
*   **Boundary 1 (User Space):** The Python backend operates within the User's security context. It trusts inputs from the verified Electron frontend (Localhost only) but sanitizes all LLM outputs before execution to prevent Command Injection.
*   **Boundary 2 (Checkpoints):** Tools with side-effects (File Delete, System Shutdown) require explicit logic gates or confirmation steps.
*   **Boundary 3 (External API):** All data leaving the local network (to Gemini) is treated as public; no PII (Passwords/Keys) is sent in the prompt context.

## 7. Failure Recovery
*   **API Failure:** If Gemini fails, the system logs the error and speaks a fallback "I am unable to connect" message.
*   **Process Crash:** Electron monitors the Python subprocess; fatal crashes trigger an app restart (planned feature) or error dialog.
